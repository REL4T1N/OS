# Лабораторная работа №2: Параллельная сортировка слиянием

## Цель работы
Приобретение практических навыков в управлении потоками и обеспечении синхронизации между ними в операционной системе.

## Задание
Реализация параллельной сортировки слиянием на языке C с использованием потоков POSIX (pthread). Программа должна демонстрировать работу с различными параметрами параллелизма и проводить анализ производительности.

## Требования
- Использование стандартных средств создания потоков ОС (pthread)
- Ограничение максимального количества потоков
- Возможность демонстрации количества работающих потоков
- Исследование зависимости ускорения от входных данных и количества потоков

## Структура проекта
```text
lab2/
├── src/
│ ├── main.c 
│ ├── merge_sort.c 
│ ├── merge_sort.h 
│ ├── benchmark.c 
│ ├── benchmark.h 
│ └── common.h 
├── scripts/
│ └── get_graphics.py
├── results/ # Директория для результатов тестов
├── Makefile 
└── README.md
```

## Алгоритм параллельной сортировки слиянием

### Основные концепции:
1. **Рекурсивное разделение** массива на подмассивы
2. **Параллельная обработка** левой и правой частей массива
3. **Слияние** отсортированных подмассивов
4. **Пороговые значения** для перехода к последовательной сортировке

### Ключевые параметры:
- `PARALLEL_THRESHOLD` - минимальный размер для параллельной обработки
- `SEQUENTIAL_THRESHOLD` - минимальный размер для последовательной сортировки вставками
- `MAX_DEPTH` - максимальная глубина рекурсии (ограничивает потоки)
- `MAX_THREADS` - максимальное количество потоков

## Компиляция и запуск

### Сборка проекта:
```bash
make
```
### Основные команды:
#### Тестирование (1 итерация):
```bash
make test-size          # Тест влияния размера массива
make test-depth         # Тест влияния глубины параллелизма
make test-threshold     # Тест влияния пороговых значений
make test               # Все тесты с выводом в консоль и файл
make full-test          # Все тесты с графиками
```
#### Бенчмарки (5 итераций):
```bash
make benchmark          # Все тесты по 5 раз (только в файл)
make full-benchmark     # Полный бенчмарк (тесты + графики)
```
#### Графики:
```bash
make graphics           # Построение графиков из тестов
make benchmark-graphics # Построение графиков из бенчмарков
```
#### Утилиты:
```bash
make list-results      # Показать созданные файлы результатов
make clean             # Очистка всех сгенерированных файлов
make help              # Справка по командам
```
### Параметры командной строки:
```bash
./parallel_sort [опции]

Опции:
  -s <размер>      Размер массива (по умолчанию: 100000000)
  -d <глубина>     Максимальная глубина рекурсии (по умолчанию: 4)
  -t <потоки>      Максимальное количество потоков (по умолчанию: 8)
  -p <порог>       Порог для параллельной сортировки (по умолчанию: 1000)
  -seq <порог>     Порог для последовательной сортировки (по умолчанию: 50)

Тестовые наборы:
  -size            Тест влияния размера массива
  -depth           Тест влияния глубины параллелизма
  -threshold       Тест влияния пороговых значений
  -all             Запуск всех тестов
  -h               Справка
```
## Примеры использования
```bash
# Быстрый тест
make full-test

# Полное исследование производительности
make full-benchmark

# Запуск с конкретными параметрами
./parallel_sort -s 5000000 -d 3 -p 500 -seq 100
```

## Методика исследования
### Тест 1: Влияние размера массива
- Размеры: 1M, 5M, 10M, 25M, 50M, 75M, 100M элементов
- Фиксированные: глубина=8, порог=1000

### Тест 2: Влияние глубины параллелизма
- Глубины: от 1 до 12
- Фиксированные: размер=50M, порог=1000

### Тест 3: Влияние пороговых значений
- Пороги: 100, 500, 1000, 2500, 5000, 10000, 25000, 50000
- Фиксированные: размер=50M, глубина=4

### Метрики измерения:
- Время последовательной сортировки
- Время параллельной сортировки
- Ускорение (speedup) = T_sequential / T_parallel
- Эффективность = speedup / количество_потоков
- Корректность результата

## Анализ результатов
### Ожидаемые зависимости:
1. **Размер массива:**
    - Малые массивы: низкое ускорение (накладные расходы)
    - Большие массивы: высокое ускорение (амортизация расходов)

2. **Глубина параллелизма:**
    - Оптимум зависит от размера массива и процессора
    - Слишком большая глубина → contention потоков

3. **Пороговые значения:**
    - Малый порог → больше потоков, больше накладных расходов
    - Большой порог → меньше потоков, недозагрузка CPU

## Требования к системе
- Компилятор GCC
- Python 3 с библиотеками matplotlib и numpy (для графиков)
- Операционная система с поддержкой pthread (Linux/WSL)

## Примечания
- Программа автоматически создает виртуальное окружение Python для построения графиков
- Результаты сохраняются в структурированные директории
- Для просмотра графиков в WSL рекомендуется копировать PNG файлы в Windows
- Максимальное количество потоков ограничивается как явно, так и через глубину рекурсии

## Вывод
В ходе выполнения лабораторной работы были успешно приобретены и применены на практике следующие навыки:

### 1. Работа с потоками POSIX (pthread)
- Освоено создание потоков с помощью `pthread_create()`
- На практике применены механизмы синхронизации: `pthread_join()` для ожидания завершения потоков
- Реализован контроль количества активных потоков с использованием мьютексов (`pthread_mutex_t`)

### 2. Параллельное программирование
- Реализован рекурсивный параллельный алгоритм сортировки слиянием
- Освоено управление глубиной параллелизма для ограничения количества потоков
- Применена стратегия "разделяй и властвуй" с распределением работы между потоками

### 3. Оптимизация производительности
- Исследовано влияние различных параметров на производительность:
  - Размера массива на ускорение параллельной обработки
  - Глубины рекурсии на эффективность использования потоков
  - Пороговых значений для перехода к последовательной сортировке
- Выявлен компромисс между накладными расходами и параллелизмом

В результате работы создана полнофункциональная система параллельной сортировки, демонстрирующая принципы многопоточного программирования и позволяющая проводить исследование производительности параллельных алгоритмов. Полученные навыки будут применены для разработки высокопроизводительных приложений, эффективно использующих многопроцессорные системы.