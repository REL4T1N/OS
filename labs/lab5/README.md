# Лабораторная работа 5

## **Общие основы: библиотеки, функции, константы**

### **Системные библиотеки (используются во всех ЛР):**
- **`libc.so.6`** - стандартная библиотека C (все программы)
- **`ld-linux-x86-64.so.2`** - динамический загрузчик (все динамически слинкованные программы)

### **Общие системные вызовы:**
- **`execve`** - запуск программы
- **`brk`/`mmap`** - управление памятью (куча, стеки)
- **`openat`**/`read`/`write`/`close` - работа с файлами
- **`fstat`** - получение информации о файлах
- **`mprotect`** - управление защитой памяти
- **`munmap`** - освобождение памяти
- **`exit_group`** - завершение процесса

### **Общие константы и флаги:**
- **`PROT_READ|PROT_WRITE|PROT_EXEC`** - права доступа к памяти (`<sys/mman.h>`)
- **`MAP_PRIVATE|MAP_SHARED|MAP_ANONYMOUS|MAP_FIXED`** - флаги mmap (`<sys/mman.h>`)
- **`O_RDONLY|O_WRONLY|O_RDWR|O_CREAT|O_CLOEXEC`** - флаги открытия файлов (`<fcntl.h>`)
- **`AT_FDCWD`** - специальный дескриптор для относительных путей (`<fcntl.h>`)
- **`ENOENT`** - ошибка "No such file or directory" (`<errno.h>`)
- **`STDIN_FILENO`**/`STDOUT_FILENO`/`STDERR_FILENO` - стандартные дескрипторы (`<unistd.h>`)

---

## **Лабораторная работа 1: Межпроцессное взаимодействие через pipe**

### **Библиотеки:**
- **`libc.so.6`** (стандартные функции C)
- Функции для работы с процессами и pipe

### **Функции из вашего кода:**
```c
pid_t pid;                    // Тип для PID процесса
int pipe1[2];                 // Массив для дескрипторов pipe
pid = fork();                 // Создание дочернего процесса
dup2(file_fd, STDIN_FILENO); // Перенаправление стандартного ввода
execl("./child", "child", NULL); // Запуск дочерней программы
FILE *pipe_read = fdopen(pipe1[0], "r"); // Открытие pipe как FILE*
wait(NULL);                   // Ожидание завершения дочернего процесса
```

### **Системные вызовы (из strace):**
- **`pipe2([3, 4], 0)`** - создание pipe
- **`clone(... SIGCHLD ...)`** - создание процесса (реализация `fork()`)
- **`dup2(5, 0)`**/`dup2(4, 1)` - перенаправление ввода/вывода
- **`read(3, ...)`**/`write(1, ...)` - чтение из pipe и запись
- **`wait4(-1, NULL, 0, NULL)`** - ожидание завершения дочернего процесса
- **`fcntl(3, F_GETFL)`** - получение флагов файлового дескриптора

### **Константы и флаги:**
- **`CLONE_CHILD_CLEARTID|CLONE_CHILD_SETTID|SIGCHLD`** - флаги для `clone()` (`<sched.h>`)
- **`F_GETFL`** - команда для получения флагов файла (`<fcntl.h>`)
- **`S_IFIFO|0600`** - тип файла FIFO (pipe) с правами 0600

### **Механизм работы:**
1. Создание pipe → `pipe2()`
2. Создание процесса → `fork()` → `clone()`
3. Перенаправление потоков → `dup2()`
4. Запуск программы → `execve()`
5. Обмен данными через pipe → `read()`/`write()`
6. Ожидание завершения → `wait4()`

---

## **Лабораторная работа 2: Параллельная сортировка (многопоточность)**

### **Библиотеки:**
- **`libc.so.6`** - стандартные функции
- **`libpthread.so.0`** - библиотека pthread (неявно через `libc.so.6`)
- **`librt.so.1`** - библиотека реального времени (для `clock_gettime`)

### **Функции из вашего кода:**
```c
pthread_mutex_t THREAD_MUTEX;               // Мьютекс для синхронизации
pthread_mutex_lock(&THREAD_MUTEX);          // Блокировка мьютекса
pthread_mutex_unlock(&THREAD_MUTEX);        // Разблокировка мьютекса
pthread_t left_thread, right_thread;        // Дескрипторы потоков
pthread_create(&left_thread, NULL, ...);    // Создание потока
pthread_join(left_thread, NULL);            // Ожидание завершения потока
pthread_mutex_init(&THREAD_MUTEX, NULL);    // Инициализация мьютекса
pthread_mutex_destroy(&THREAD_MUTEX);       // Уничтожение мьютекса
clock_gettime(CLOCK_MONOTONIC, &ts);        // Получение времени
```

### **Системные вызовы (из strace):**
- **`clone3(... CLONE_THREAD ...)`** - создание потока (реализация `pthread_create()`)
- **`futex(... FUTEX_WAIT_BITSET ...)`** - синхронизация (реализация `pthread_join()`)
- **`mmap(... MAP_STACK ...)`** - выделение стека для потока
- **`rt_sigaction(SIGRT_1, ...)`** - установка обработчика сигналов

### **Константы и флаги:**
- **`CLONE_VM|CLONE_FS|CLONE_FILES|CLONE_SIGHAND|CLONE_THREAD`** - флаги создания потока (`<sched.h>`)
- **`FUTEX_WAIT_BITSET|FUTEX_CLOCK_REALTIME`** - флаги futex (`<linux/futex.h>`)
- **`FUTEX_BITSET_MATCH_ANY`** - маска для пробуждения (`<linux/futex.h>`)
- **`MAP_STACK`** - флаг для выделения памяти под стек (`<sys/mman.h>`)
- **`CLOCK_MONOTONIC`** - монотонные часы (`<time.h>`)
- **`SIGRT_1`** - сигнал реального времени (`<signal.h>`)

### **Механизм работы:**
1. Инициализация мьютекса → внутренние структуры ядра
2. Создание потоков → `pthread_create()` → `clone3(CLONE_THREAD)`
3. Синхронизация → `pthread_mutex_lock()` → `futex()`
4. Управление памятью → `mmap(MAP_STACK)` для стеков потоков
5. Ожидание завершения → `pthread_join()` → `futex(FUTEX_WAIT_BITSET)`

---

## **Лабораторная работа 3: Разделяемая память (shared memory)**

### **Библиотеки:**
- **`libc.so.6`** - стандартные функции
- **`librt.so.1`** - POSIX shared memory (`shm_open`)

### **Функции из вашего кода:**
```c
shm_unlink(name);                                  // Удаление shared memory
shm_open(name, O_CREAT | O_RDWR, 0666);           // Создание/открытие shared memory
ftruncate(fd, sizeof(shared_memory));             // Установка размера
shared_memory *shm = mmap(NULL, sizeof(shared_memory), 
                         PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0); // Отображение
munmap(shm, sizeof(shared_memory));               // Отключение отображения
```

### **Системные вызовы (из strace):**
- **`openat(AT_FDCWD, "/dev/shm/sum_calc_shm_1", O_RDWR|O_CREAT|O_NOFOLLOW|O_CLOEXEC, 0666)`** - создание shared memory
- **`ftruncate(3, 4104)`** - установка размера объекта
- **`mmap(NULL, 4104, PROT_READ|PROT_WRITE, MAP_SHARED, 3, 0)`** - отображение в память
- **`unlink("/dev/shm/sum_calc_shm_1")`** - удаление объекта

### **Константы и флаги:**
- **`O_CREAT|O_RDWR|O_NOFOLLOW`** - флаги создания shared memory (`<fcntl.h>`)
- **`MAP_SHARED`** - флаг для разделяемого отображения (`<sys/mman.h>`)
- **`0666`** - права доступа к shared memory

### **Механизм работы:**
1. Удаление старого объекта → `shm_unlink()` → `unlink()`
2. Создание объекта → `shm_open()` → `openat()` в `/dev/shm/`
3. Установка размера → `ftruncate()`
4. Отображение в память → `mmap(MAP_SHARED)`
7. Удаление → `shm_unlink()` → `unlink()`

---

## **Лабораторная работа 4: Динамические библиотеки (2 программы)**

### **Программа 1: Статическое связывание**

### **Библиотеки:**
- **`libc.so.6`** - стандартная библиотека C
- **`libm.so.6`** - математическая библиотека
- **`lib1.so`** - пользовательская библиотека

### **Системные вызовы (из strace):**
- **`openat` с путями `glibc-hwcaps/x86-64-v[2-4]/lib1.so`** - поиск оптимизированных версий
- **`newfstatat(AT_FDCWD, "...", ..., 0)`** - проверка существования директорий
- **`openat(AT_FDCWD, "/mnt/c/C/OS/labs/lab4/build/lib/lib1.so", O_RDONLY|O_CLOEXEC)`** - загрузка библиотеки
- **`mmap` с `MAP_DENYWRITE`** - отображение библиотеки в память
- **`mprotect` на секциях `lib1.so`** - настройка прав доступа

### **Константы и флаги:**
- **`MAP_DENYWRITE`** - запрет записи в файл библиотеки (`<sys/mman.h>`)
- **`R_OK`** - проверка права на чтение (`<unistd.h>`)

### **Механизм работы:**
2. Поиск оптимизированных версий библиотек → проверка `glibc-hwcaps`
3. Загрузка библиотек → `openat()` + `mmap()`
4. Настройка защиты памяти → `mprotect()`
5. Вызов функций из библиотеки

---

### **Программа 2: Динамическая загрузка (dlopen)**

### **Библиотеки:**
- **`libc.so.6`** - стандартная библиотека C
- **`libdl.so.2`** - библиотека динамической загрузки (для `dlopen`)
- **`libm.so.6`** - математическая библиотека
- **`lib1.so`**/`lib2.so` - пользовательские библиотеки

### **Функции из вашего кода:**
```c
dlopen(lib_names[lib_num - 1], RTLD_LAZY);  // Динамическая загрузка библиотеки
dlclose(lib_handle);                         // Выгрузка библиотеки
dlerror();                                   // Получение ошибки
GCF = (gcf_func)dlsym(lib_handle, "GCF");   // Получение указателя на функцию
```

### **Системные вызовы (из strace):**
- **`openat(AT_FDCWD, "./build/lib/lib1.so", O_RDONLY|O_CLOEXEC)`** (после старта) - результат `dlopen()`
- **`getcwd("/mnt/c/C/OS/labs/lab4", 128)`** - получение текущей директории
- **`munmap(0x7f23b6819000, 16416)`** - результат `dlclose()`
- **Повторная загрузка `libm.so.6`** - загрузка зависимостей
- **Переключение библиотек** → `munmap()` + новый `openat()`

### **Константы и флаги:**
- **`RTLD_LAZY`** - отложенное разрешение символов (`<dlfcn.h>`)
- **`O_NOFOLLOW`** - не следовать символическим ссылкам (`<fcntl.h>`)

### **Механизм работы:**
1. Загрузка библиотеки по требованию → `dlopen()` → `openat()` + `mmap()`
2. Получение указателей на функции → `dlsym()`
3. Вызов функций через полученные указатели
4. Выгрузка библиотеки → `dlclose()` → `munmap()`

---

## **Анализ всех лабораторных работ:**

### **Общие закономерности:**
1. Все программы начинаются с `execve()` и загрузки `libc.so.6`
2. Динамический загрузчик всегда проверяет `/etc/ld.so.cache`
3. Управление памятью осуществляется через `mmap()`/`munmap()`
4. Защита памяти настраивается через `mprotect()`
5. Для синхронизации используются различные механизмы в зависимости от задачи
6. Обработка ошибок через проверку возвращаемых значений и `errno`

### **Эволюция сложности:**
1. **ЛР1:** Базовые процессы + pipe
2. **ЛР2:** Потоки + сложная синхронизация + оптимизация памяти
3. **ЛР3:** Разделяемая память + файловая система `/dev/shm/`
4. **ЛР4:** Динамические библиотеки + управление загрузкой во время выполнения

## **Краткий вывод о работе с strace**

### **Что я узнал из работы с strace?**

1. **Реальное поведение программ:** Strace показывает, как программы **фактически** взаимодействуют с ядром ОС, а не как они написаны в коде. Видно все системные вызовы, которые делают библиотеки (libc, pthread и др.).

2. **Архитектура системных вызовов:** Понял иерархию и последовательность вызовов:
   - Инициализация процесса (`execve` → загрузка библиотек → настройка памяти)
   - Работа с ресурсами (файлы, память, процессы)
   - Синхронизация и IPC
   - Завершение работы

4. **Загрузка динамических библиотек:** Понял полный процесс:
   - Поиск библиотек (кэш, hwcaps, относительные пути)
   - Отображение в память (`mmap` с разными правами)
   - Настройка защиты (`mprotect`)

### **Для чего и когда используется strace?**

**Основные применения:**

1. **Отладка программ:**
   - Поиск причин падений (последний вызов перед ошибкой)
   - Анализ "зависаний" (на каком вызове программа ждет)
   - Поиск утечек ресурсов (незакрытые файловые дескрипторы)

2. **Профилирование и оптимизация:**
   - Поиск "узких мест" (часто вызываемые или медленные syscalls)
   - Анализ паттернов доступа к файлам/сети
   - Оптимизация количества системных вызовов

3. **Анализ безопасности:**
   - Проверка, к каким файлам/сетям обращается программа
   - Обнаружение подозрительной активности
   - Аудит прав доступа

4. **Обучение и исследование:**
   - Понимание работы ОС на низком уровне
   - Анализ поведения сторонних программ
   - Исследование системных механизмов

5. **Диагностика в продакшене:**
   - Анализ проблем без остановки сервиса
   - Поиск причин медленной работы
   - Воспроизведение редких багов

### **Преимущества strace**

1. **Не требует модификации кода:** Можно анализировать любую программу, даже без исходников.
2. **Низкоуровневая информация:** Показывает реальное взаимодействие с ядром.
3. **Кросс-платформенность:** Аналоги есть для разных ОС (strace Linux, dtruss macOS, ktrace BSD).
4. **Гибкость фильтрации:** Можно отслеживать только определенные вызовы, процессы, типы ошибок.
5. **Малое влияние на производительность:** В сравнении с другими инструментами отладки.
6. **Понятный вывод:** Человекочитаемый формат с параметрами и возвращаемыми значениями.

### **Недостатки strace**

1. **Не показывает внутреннюю логику программы:** Только системные вызовы, не видно что происходит "внутри" процесса.
2. **Производительность:** Замедляет программу в 2-10 раз (особенно при trace всех вызовов).
3. **Не отслеживает системные события:** Не показывает прерывания, планирование, работу с памятью на уровне ядра.
4. **Сложность анализа больших программ:** Огромный объем вывода для сложных приложений.
5. **Проблемы с многопоточностью:** Может пропускать вызовы при высокой конкуренции потоков.
6. **Ограничения безопасности:** Требует прав root для отслеживания чужих процессов.

### **Когда НЕ использовать strace?**

1. **Для высоконагруженных продакшен-систем** (слишком большое влияние на производительность).
2. **Для анализа внутренней алгоритмической сложности** (лучше профилировщики типа perf, gprof).
4. **Для долгосрочного мониторинга** (лучше специализированные мониторинговые системы).
5. **Когда программа использует много косвенных вызовов** (сигналы, асинхронный ввод-вывод).

---

## **Итоговые выводы для лабораторной работы**

Работа с **strace** позволила:

✅ **Понять реальное поведение** написанных программ на уровне ОС  
✅ **Сравнить разные механизмы IPC** (pipe, shared memory, threads) на системном уровне  
✅ **Увидеть полный жизненный цикл** процессов и потоков  
✅ **Проанализировать загрузку динамических библиотек**  
✅ **Понять принципы синхронизации** (futex, сигналы, ожидание)  
✅ **Увидеть оптимизации ОС** (кэширование, отложенная загрузка, управление памятью)  

---
*Лабораторная работа выполнена в рамках курса "Операционные системы"*